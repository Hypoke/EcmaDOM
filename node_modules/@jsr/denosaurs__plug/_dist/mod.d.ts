import type { FetchOptions } from "./types.js";
export type { ArchRecord, CacheLocation, CacheOptions, CacheSetting, CrossOptions, FetchOptions, NamedOptions, NestedCrossRecord, OsRecord, URLOptions } from "./types.js";
export { download } from "./download.js";
type Cast<A, B> = A extends B ? A : B;
type Const<T> = Cast<T, (T extends string | number | bigint | boolean ? T : never) | {
  [K in keyof T]: Const<T[K]>;
} | []>;
/**
 * Opens a dynamic library and registers symbols, compatible with
 * {@link Deno.dlopen} yet with extended functionality allowing you to use
 * remote (or local) binaries, automatically building the binary name and
 * controlling the caching policy.
 *
 * @example
 * ```ts
 * import { dlopen, FetchOptions } from "@denosaurs/plug";
 *
 * // Configure plug to automatically guess the binary names for you, even when
 * // there for example are special rules for naming on specific architectures
 * const options: FetchOptions = {
 *   name: "test",
 *   url: "https://example.com/some/path/",
 *   suffixes: {
 *     darwin: {
 *       aarch64: ".aarch64",
 *       x86_64: ".x86_64",
 *     },
 *   },
 *   // Becomes:
 *   // darwin-aarch64: "https://example.com/some/path/libexample.aarch64.dylib"
 *   // darwin-x86_64: "https://example.com/some/path/libexample.x86_64.dylib"
 * };
 *
 * await dlopen(options, {});
 * ```
 *
 * @param options See {@link FetchOptions}
 * @param symbols A record extending {@link Deno.ForeignLibraryInterface}
 * @returns An opened {@link Deno.DynamicLibrary}
 */ export declare function dlopen<S extends Deno.ForeignLibraryInterface>(options: FetchOptions, symbols: Const<S>): Promise<Deno.DynamicLibrary<S>>;
//# sourceMappingURL=mod.d.ts.map